<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Abstract Atelier</title>
<!-- Tailwind CSS -->
<script src="https://cdn.tailwindcss.com"></script>
<script>
  tailwind.config = { darkMode: 'class' }
</script>
<!-- Fonts -->
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Fira+Mono:wght@500;700&display=swap" rel="stylesheet">
<link rel="icon" type="image/x-icon" href="icon.ico">
<!-- Quill CSS -->
<link href="https://cdn.jsdelivr.net/npm/quill@2.0.2/dist/quill.snow.css" rel="stylesheet">
<style>
  :root { --primary: #007aff; --toolbar-bg: rgba(255,255,255,.65); --toolbar-border: rgba(0,0,0,.06); --guide-line: rgba(15,23,42,.12); --toolbar-icon: #111827 }
  .dark:root { --toolbar-bg: rgba(3,7,18,.65); --toolbar-border: rgba(255,255,255,.12); --guide-line: rgba(148,163,184,.22); --toolbar-icon: #f5f5f6 }
  body { font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background: #fdfcf7 }
  .dark body { background: #0b1120 }
  /* Smoothen theme transitions for key UI surfaces */
  /* :root, body, .ql-editor, #topbar, #statusbar, #popup, .infinite-fade-top, main::before, main::after {
    transition: background-color 5s ease, color .1s ease;
  } */

  /* Header title */
  .header-title { font-family: 'Fira Mono', monospace; letter-spacing: -0.02em }

  /* Quill base polishing */
  .ql-container { border: 0 !important; background: transparent }
  .ql-editor { font-size: 16px; line-height: 1.5; background: transparent; color: #111827 }
  .ql-editor p { margin-bottom: .5em }
  .ql-editor p:last-child { margin-bottom: 0 }
  .ql-container.ql-snow:focus-within,
  .ql-editor:focus,
  .ql-editor:focus-visible,
  .ql-editor:-moz-focusring { outline: none !important; box-shadow: none !important }
  .dark .ql-editor { color: #e5e7f5 }
  .ql-editor a { text-decoration-color: rgba(37,99,235,.45) }
  .ql-editor a:hover { text-decoration-color: rgba(29,78,216,.6) }
  .ql-editor ol, .ql-editor ul { margin-bottom: .75em; padding-left: 1.25em }
  .ql-editor li { margin-bottom: .35em }
  #popup .ql-pmid { text-decoration: none; }
  #popup .ql-pmid:hover { text-decoration: none; }

  /* Toolbar translucent with shadows */
  #topbar { backdrop-filter: saturate(130%) blur(14px); -webkit-backdrop-filter: saturate(130%) blur(14px); background: var(--toolbar-bg); border-color: var(--toolbar-border); box-shadow: none; }

  /* FLOATING STATUSBAR PILL */
  #statusbar { position: fixed; left: 50%; bottom: 16px; transform: translateX(-50%); z-index: 60; display: inline-flex; align-items: center; justify-content: center; gap: 14px; padding: 10px var(--pill-pad, 16px); border-radius: 9999px; border: 1px solid var(--toolbar-border); backdrop-filter: saturate(120%) blur(12px); -webkit-backdrop-filter: saturate(120%) blur(12px); background: var(--toolbar-bg); box-shadow: 0 10px 30px rgba(0,0,0,.18), 0 2px 6px rgba(0,0,0,.12); flex-wrap: nowrap; transition: padding .25s ease }
  #statusbar:hover, #statusbar:focus-within { padding: 10px var(--pill-pad-expanded, calc(var(--pill-pad, 16px) + 12px)) }
  .dark #statusbar { box-shadow: 0 14px 36px rgba(0,0,0,.5), 0 2px 8px rgba(0,0,0,.45) }
  #statusbar span { white-space: nowrap }
  #statusbar .stat { display: inline-flex; align-items: center; gap: 6px; font-variant-numeric: tabular-nums }
  #statusbar .stat svg { flex-shrink: 0 }
  #statusbar .stat { position: relative }
  #statusbar .stat-label { opacity: 0; font-size: .65rem; letter-spacing: .04em; text-transform: uppercase; color: inherit; max-width: 0; overflow: hidden; margin-left: 0; transition: opacity .22s ease, transform .22s ease, max-width .22s ease, margin-left .22s ease; transform: translateY(4px) }
  #statusbar:hover .stat-label,
  #statusbar:focus-within .stat-label { opacity: .75; transform: translateY(0); max-width: 40px; margin-left: 4px }
  #statusbar .stat-total { font-weight: 600 }

  /* Quill toolbar visuals */
  /* Quill will add .ql-toolbar automatically to #toolbar after initialization */
  .ql-toolbar.ql-snow { box-shadow: none; border-radius: 9999px; }
  .ql-toolbar { border: 0 !important; background: transparent !important; display: flex; align-items: center; justify-content: center; gap: .5rem; overflow-x: auto; overflow-y: hidden; white-space: nowrap; flex-wrap: nowrap; scrollbar-width: thin; -webkit-overflow-scrolling: touch }
  .ql-toolbar .ql-formats { margin: 0; flex-shrink: 0; display: inline-flex; align-items: center; gap: .5rem }
  .ql-toolbar button, .ql-toolbar .ql-picker { height: 26px; flex-shrink: 0 }
  .ql-toolbar .ql-picker-label, .ql-toolbar button { display: inline-flex; align-items: center }
  .ql-toolbar .ql-stroke { stroke: #111827 }
  .ql-toolbar .ql-fill { fill: #111827 }
  .dark .ql-toolbar .ql-stroke { stroke: #f5f5f6 }
  .dark .ql-toolbar .ql-fill { fill: #f5f5f6 }
  .ql-custom-btn { border: none; border-radius: 3px; width: 28px; height: 28px; display: inline-flex; align-items: center; justify-content: center; cursor: pointer; padding: 0; color: var(--toolbar-icon); background: transparent }
  .ql-custom-btn svg { pointer-events: none }
  .ql-custom-btn:hover, .ql-custom-btn:focus-visible { color: rgba(59,130,246,1); outline: none }
  .ql-custom-btn.ql-active { color: rgba(29,78,216,1) }
  .dark .ql-custom-btn { background: transparent }
  .dark .ql-custom-btn:hover, .dark .ql-custom-btn:focus-visible { color: rgba(191,219,254,1) }
  .dark .ql-custom-btn.ql-active { color: rgba(147,197,253,1) }
  @media (max-width: 640px) {
    .ql-toolbar { justify-content: flex-start }
  }

  /* PMID token */
  .ql-pmid { background: #dbeafe; color: var(--primary); border-radius: 6px; padding: 1px 6px; font-weight: 700; cursor: pointer; white-space: nowrap }
  .dark .ql-pmid { background: #1e3a8a; color: #93c5fd }

  /* Editor host and infinite look */
  #editor-card { border: 0 !important; box-shadow: none !important; background: transparent }
  #editor-shell { min-height: 0 }
  main { position: relative }
  main::before, main::after {
    content: '';
    position: absolute;
    top: -60px;
    bottom: -120px;
    width: 2px;
    pointer-events: none;
    background: linear-gradient(to bottom, transparent 0%, var(--guide-line) 14%, var(--guide-line) 86%, transparent 100%);
    opacity: .6;
  }
  main::before { left: clamp(0.75rem, 4vw, 1.5rem); transform: translateX(-0.75rem) }
  main::after { right: clamp(0.75rem, 4vw, 1.5rem); transform: translateX(0.75rem) }

  /* Top and bottom fades to imply infinite page */
  .infinite-fade-top { display: none }
  .dark .infinite-fade-top { display: none }

  /* Popup - translucent glass */
  #popup { position: fixed; max-width: 640px; width: 92vw; background: rgba(255,255,255,.78); border: 1px solid rgba(0,0,0,.06); border-radius: 14px; backdrop-filter: saturate(120%) blur(10px); -webkit-backdrop-filter: saturate(120%) blur(10px); box-shadow: 0 20px 50px rgba(0,0,0,.25); z-index: 70 }
  .dark #popup { background: rgba(2,6,23,.78); border-color: rgba(255,255,255,.12); color: #e5e7eb; box-shadow: 0 20px 50px rgba(0,0,0,.5) }
  #popup .abstract-box { border: 1px solid var(--toolbar-border); background: rgba(255,255,255,.55); }
  .dark #popup .abstract-box { border-color: var(--toolbar-border); background: rgba(15,23,42,.45); }
  .nice-scroll::-webkit-scrollbar { width: 10px }
  .nice-scroll::-webkit-scrollbar-thumb { background: rgba(100,100,100,.35); border-radius: 8px }
</style>
</head>
<body class="antialiased bg-gray-50 dark:bg-gray-950 text-gray-900 dark:text-gray-100 min-h-screen selection:bg-blue-200 dark:selection:bg-blue-900">

<!-- Top bar: Title + Theme toggle + Quill toolbar (centered) -->
<div id="topbar" class="fixed top-0 inset-x-0 z-50 border-b">
  <div class="max-w-7xl mx-auto px-4">
    <div class="py-3 flex flex-col items-center justify-center gap-1.5">
      <h1 class="header-title text-xl font-bold text-stone-700 dark:text-stone-100">Abstract Atelier</h1>
      <p class="italic text-xs text-stone-500 dark:text-stone-300">by Mohammad Almeqdadi, MD</p>
    </div>
  </div>
  <!-- Important: Use a dedicated toolbar container with a stable id. Do NOT pre-apply .ql-toolbar -->
  <div id="toolbar">
    <span class="ql-formats">
      <button id="theme-toggle" type="button" aria-label="Toggle theme" class="ql-custom-btn ql-theme-btn"></button>
      <button id="copy-html" type="button" aria-label="Copy as HTML" class="ql-custom-btn">
        <svg id="copy-icon" xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 transition-transform duration-200" viewBox="0 0 24 24" fill="currentColor">
          <path d="M16 1H4a2 2 0 0 0-2 2v14h2V3h12V1zm3 4H8a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2zm-1 16H8V7h11v14z"/>
        </svg>
      </button>
      <button id="export-pdf" type="button" aria-label="Export to PDF" class="ql-custom-btn">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
          <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
        </svg>
      </button>
    </span>
    <span class="ql-formats">
      <button class="ql-bold"></button>
      <button class="ql-italic"></button>
      <button class="ql-underline"></button>
    </span>
    <span class="ql-formats">
      <button class="ql-align" value=""></button>
      <button class="ql-align" value="center"></button>
      <button class="ql-align" value="justify"></button>
    </span>
    <span class="ql-formats">
      <button class="ql-list" value="ordered"></button>
      <button class="ql-list" value="bullet"></button>
    </span>
    <span class="ql-formats">
      <button class="ql-clean"></button>
    </span>
  </div>
</div>

<!-- Main -->
<main class="max-w-3xl mx-auto px-4 md:px-8 pt-28 pb-24 overflow-visible">
  <div id="editor-card">
    <div id="editor-shell">
      <div id="editor"></div>
    </div>
  </div>
</main>
<div class="infinite-fade-top"></div>

<!-- Floating status pill -->
<div id="statusbar" class="text-sm text-gray-700 dark:text-gray-300" role="status" aria-live="polite">
  <span class="stat" id="s-words" data-label="Words" aria-label="Words 0">
    <svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.6" class="h-4 w-4">
      <path d="M4 5h12M4 10h9M4 15h8" stroke-linecap="round"/>
    </svg>
    <span class="stat-label" aria-hidden="true">Words</span>
    <span class="stat-text">0</span>
  </span>
  <span class="separator">•</span>
  <span class="stat" id="s-chars" data-label="Chars" aria-label="Chars 0">
    <svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.6" class="h-4 w-4">
      <path d="M5 15L10 5l5 10M7 13h6" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
    <span class="stat-label" aria-hidden="true">Chars</span>
    <span class="stat-text">0</span>
  </span>
  <span class="separator">•</span>
  <span class="stat" id="s-pmids" data-label="PMIDs" aria-label="PMIDs 0">
    <svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.6" class="h-4 w-4">
      <path d="M6 4h6l3 3v9H6z" stroke-linejoin="round"/>
      <path d="M12 4v3h3" stroke-linejoin="round"/>
      <path d="M8 9h5M8 12h5M8 15h5" stroke-linecap="round"/>
    </svg>
    <span class="stat-label" aria-hidden="true">PMIDs</span>
    <span class="stat-text">0</span>
  </span>
</div>

<!-- Popup -->
<div id="popup" class="hidden p-4 shadow-2xl"></div>

<!-- Quill JS -->
<script src="https://cdn.jsdelivr.net/npm/quill@2.0.2/dist/quill.js"></script>
<script>
  (() => {
    const $ = (selector, scope = document) => scope.querySelector(selector)
    const sleep = ms => new Promise(resolve => setTimeout(resolve, ms))
    const pmidPattern = /(\[\s*PMID\s*:\s*(\d{7,9})\s*\])|(?:PMID\s*:\s*(\d{7,9}))|(?:PMID\s+(\d{7,9}))|(?:PMID(\d{7,9}))|\b(\d{7,9})\b/g
    const icons = {
      sun: '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="M4.93 4.93l1.41 1.41"/><path d="M17.66 17.66l1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="M6.34 17.66l-1.41 1.41"/><path d="M19.07 4.93l-1.41 1.41"/></svg>',
      moon: '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>'
    }

    const debounce = (fn, delay = 120) => {
      let id
      return (...args) => {
        clearTimeout(id)
        id = setTimeout(() => fn(...args), delay)
      }
    }

    const createAnchorForPMID = node => {
      const pmid = node.getAttribute('data-pmid') || (node.textContent.match(/\d{7,9}/) || [])[0]
      if (!pmid) return
      const anchor = document.createElement('a')
      anchor.href = 'https://pubmed.ncbi.nlm.nih.gov/' + pmid + '/'
      anchor.textContent = node.textContent
      anchor.target = '_blank'
      anchor.rel = 'noopener noreferrer'
      node.replaceWith(anchor)
    }

    const registerQuillExtensions = () => {
      const Inline = Quill.import('blots/inline')
      class PMIDBlot extends Inline {
        static create(value) {
          const node = super.create()
          if (value && value !== true) node.setAttribute('data-pmid', value)
          node.classList.add('ql-pmid')
          return node
        }
        static formats(node) {
          return node.getAttribute('data-pmid') || false
        }
      }
      PMIDBlot.blotName = 'pmid'
      PMIDBlot.tagName = 'span'
      Quill.register(PMIDBlot, true)

      const Size = Quill.import('attributors/style/size')
      Size.whitelist = ['12px','14px','16px','18px','20px','22px','24px','26px','28px']
      Quill.register(Size, true)
    }

    const initThemeToggle = () => {
      const root = document.documentElement
      const body = document.body
      const btn = $('#theme-toggle')
      if (!btn) return
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches
      const storedTheme = localStorage.getItem('theme')
      let isDark = storedTheme ? storedTheme === 'dark' : prefersDark
      const render = () => {
        root.classList.toggle('dark', isDark)
        body.classList.toggle('dark', isDark)
        btn.innerHTML = isDark ? icons.sun : icons.moon
        btn.classList.remove('ql-active')
      }
      render()
      btn.addEventListener('click', () => {
        isDark = !root.classList.contains('dark')
        render()
        localStorage.setItem('theme', isDark ? 'dark' : 'light')
      })
    }

    const initQuill = () => {
      registerQuillExtensions()
      const toolbarEl = document.getElementById('toolbar')
      if (!toolbarEl) throw new Error('Toolbar container #toolbar not found in DOM at init time')
      const quill = new Quill('#editor', {
        theme: 'snow',
        placeholder: '',
        modules: { toolbar: toolbarEl },
        formats: ['bold','italic','underline','list','align','pmid','size']
      })
      return { quill, toolbarEl }
    }

    const setupToolbarSnap = (toolbarEl, quill) => {
      const getToolbarNode = () => {
        if (toolbarEl.classList.contains('ql-toolbar')) return toolbarEl
        return toolbarEl.querySelector('.ql-toolbar')
      }
      const snapToolbarToStart = (behavior = 'auto') => {
        const node = getToolbarNode()
        if (!node) return
        if (node.scrollWidth <= node.clientWidth) return
        try {
          node.scrollTo({ left: 0, behavior })
        } catch (_) {
          node.scrollLeft = 0
        }
      }
      requestAnimationFrame(() => {
        quill.focus()
        snapToolbarToStart('auto')
      })
      window.addEventListener('resize', () => snapToolbarToStart('auto'), { passive: true })
    }

    const initExport = quill => {
      const exportBtn = document.getElementById('export-pdf')
      if (!exportBtn) return
      const handleExport = () => {
        exportBtn.classList.add('ql-active')
        setTimeout(() => exportBtn.classList.remove('ql-active'), 400)
        const clone = document.createElement('div')
        clone.innerHTML = quill.root.innerHTML
        clone.querySelectorAll('.ql-pmid').forEach(createAnchorForPMID)
        const printWindow = window.open('', '_blank', 'width=900,height=700')
        if (!printWindow) return
        const markup = `<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Abstract Atelier Export</title>
  <style>
    body { font-family: "Inter", Arial, sans-serif; margin: 40px; line-height: 1.5; font-size: 11pt; color: #111827; }
    h1, h2, h3 { color: #0f172a; margin-bottom: .6em; }
    a { color: #1d4ed8; text-decoration: underline; }
    p { margin-bottom: .6em; }
    ul, ol { padding-left: 1.25rem; margin-bottom: .75em; }
    li { margin-bottom: .35em; }
  </style>
</head>
<body>${clone.innerHTML}</body>
</html>`
        printWindow.document.write(markup)
        printWindow.document.close()
        printWindow.focus()
      }
      exportBtn.addEventListener('click', handleExport)
    }

    const initCopy = quill => {
      const copyBtn = document.getElementById('copy-html')
      const copyIcon = document.getElementById('copy-icon')
      if (!copyBtn || !copyIcon) return
      const renderCopiedState = copied => {
        if (copied) {
          copyBtn.classList.add('ql-active')
          copyIcon.innerHTML = '<path d="M9 16.2 5.5 12.7l1.4-1.4 2.1 2.1 4.2-4.2 1.4 1.4-5.6 5.6z"/>'
          copyIcon.setAttribute('viewBox', '0 0 24 24')
          copyIcon.setAttribute('fill', 'currentColor')
          copyIcon.classList.add('scale-110')
        } else {
          copyBtn.classList.remove('ql-active')
          copyIcon.innerHTML = '<path d="M16 1H4a2 2 0 0 0-2 2v14h2V3h12V1zm3 4H8a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2zm-1 16H8V7h11v14z"/>'
          copyIcon.setAttribute('viewBox', '0 0 24 24')
          copyIcon.setAttribute('fill', 'currentColor')
          copyIcon.classList.remove('scale-110')
        }
      }
      const showCopySuccess = () => {
        renderCopiedState(true)
        setTimeout(() => renderCopiedState(false), 700)
      }
      const buildClipboardItems = (plain, html) => {
        if (typeof ClipboardItem === 'undefined') return null
        try {
          return [
            new ClipboardItem({ 'text/plain': new Blob([plain], { type: 'text/plain' }) }),
            new ClipboardItem({ 'text/html': new Blob([html], { type: 'text/html' }) })
          ]
        } catch (error) {
          console.warn('Failed to build ClipboardItem payload, falling back to execCommand.', error)
          return null
        }
      }
      const handleCopy = async () => {
        const clone = document.createElement('div')
        clone.innerHTML = quill.root.innerHTML
        clone.querySelectorAll('.ql-pmid').forEach(createAnchorForPMID)
        const html = clone.innerHTML
        const plain = clone.textContent || ''
        const clipboardItems = buildClipboardItems(plain, html)
        if (clipboardItems) {
          try {
            await navigator.clipboard.write(clipboardItems)
            showCopySuccess()
            return
          } catch (err) {
            console.warn('Navigator clipboard write failed, attempting fallback.', err)
          }
        }
        const temp = document.createElement('div')
        temp.contentEditable = 'true'
        temp.style.position = 'fixed'
        temp.style.left = '-9999px'
        temp.innerHTML = html
        document.body.appendChild(temp)
        const selection = window.getSelection()
        const range = document.createRange()
        range.selectNodeContents(temp)
        selection.removeAllRanges()
        selection.addRange(range)
        const success = document.execCommand('copy')
        selection.removeAllRanges()
        document.body.removeChild(temp)
        if (success) {
          showCopySuccess()
        } else {
          console.error('Fallback copy failed')
          alert('Unable to copy. Please ensure clipboard permissions are granted.')
        }
      }
      copyBtn.addEventListener('click', handleCopy)
    }

    const initLayout = quill => {
      const topbarEl = document.getElementById('topbar')
      const editorShell = document.getElementById('editor-shell')
      const getScroller = () => quill.scrollingContainer || quill.root?.parentElement || document.querySelector('#editor .ql-editor')?.parentElement || null
      const smoothScrollBy = (el, dy) => {
        if (!dy) return
        try {
          el.scrollTo({ top: el.scrollTop + dy, behavior: 'smooth' })
        } catch (_) {
          el.scrollTop += dy
        }
      }
      const setMinHeights = () => {
        const topH = topbarEl?.offsetHeight || 0
        document.documentElement.style.setProperty('--topbar-height', topH + 'px')
        const H = Math.max(0, window.innerHeight - topH)
        if (editorShell) editorShell.style.minHeight = H + 'px'
        const editorEl = document.querySelector('#editor .ql-editor')
        if (editorEl) editorEl.style.minHeight = H + 'px'
      }
      const recalcAnchors = () => {
        const scroller = getScroller()
        if (!scroller) return
        scroller.style.paddingTop = '16px'
        scroller.style.paddingBottom = '24px'
      }
      const ANCHOR_TOP_PX = 16
      const ensureCaretBelowTop = () => {
        const scroller = getScroller()
        if (!scroller) return
        const range = quill.getSelection()
        if (!range) return
        const bounds = quill.getBounds(range.index, range.length)
        if (bounds && typeof bounds.top === 'number' && bounds.top < ANCHOR_TOP_PX) {
          smoothScrollBy(scroller, bounds.top - ANCHOR_TOP_PX)
        }
      }
      const redoLayout = () => {
        setMinHeights()
        recalcAnchors()
      }
      requestAnimationFrame(redoLayout)
      window.addEventListener('resize', redoLayout, { passive: true })
      quill.on('selection-change', () => {
        redoLayout()
        ensureCaretBelowTop()
      })
      return { ensureCaretBelowTop, redoLayout, topbarEl }
    }

    const initStatsAndHighlighting = (quill, ensureCaretBelowTop) => {
      const statusbar = $('#statusbar')
      const wordsStat = $('#s-words')
      const charsStat = $('#s-chars')
      const pmidsStat = $('#s-pmids')
      if (!wordsStat || !charsStat || !pmidsStat) return
      const extractPMIDs = text => {
        const out = new Set()
        let match
        pmidPattern.lastIndex = 0
        while ((match = pmidPattern.exec(text)) !== null) {
          const value = match[2] || match[3] || match[4] || match[5] || match[6]
          if (value) out.add(value)
        }
        return [...out]
      }
      const updateStats = () => {
        const text = quill.getText()
        const trimmedText = text.trim()
        const words = trimmedText ? trimmedText.split(/\s+/).length : 0
        const chars = trimmedText.length
        const pmidCount = extractPMIDs(trimmedText).length
        const selection = quill.getSelection()
        let selectionWords = 0
        let selectionChars = 0
        let selectionPmids = 0
        const hasSelection = !!(selection && selection.length > 0)
        if (hasSelection) {
          const selectionText = quill.getText(selection.index, selection.length)
          const trimmedSelection = selectionText.trim()
          selectionWords = trimmedSelection ? trimmedSelection.split(/\s+/).length : 0
          selectionChars = trimmedSelection.length
          selectionPmids = extractPMIDs(trimmedSelection).length
        }
        const renderStat = (statEl, selectionValue, totalValue, label) => {
          const statTextEl = statEl.querySelector('.stat-text')
          if (!statTextEl) return
          statTextEl.innerHTML = ''
          if (hasSelection) {
            statTextEl.append(document.createTextNode(selectionValue + '/'))
          }
          const totalSpan = document.createElement('span')
          totalSpan.className = 'stat-total'
          totalSpan.textContent = totalValue
          statTextEl.append(totalSpan)
          const labelValue = hasSelection ? selectionValue + '/' + totalValue : totalValue
          statEl.setAttribute('aria-label', label + ' ' + labelValue)
        }
        renderStat(wordsStat, selectionWords, words, 'Words')
        renderStat(charsStat, selectionChars, chars, 'Chars')
        renderStat(pmidsStat, selectionPmids, pmidCount, 'PMIDs')
        if (!statusbar) return
        const statDigits = (hasSelection
          ? [selectionWords, words, selectionChars, chars, selectionPmids, pmidCount]
          : [words, chars, pmidCount])
          .reduce((sum, value) => sum + String(value).length, 0)
        const totalDigits = statDigits + (hasSelection ? 3 : 0)
        const basePad = 16 + Math.min(12, Math.max(0, totalDigits - 3)) * 1.2
        statusbar.style.setProperty('--pill-pad', basePad + 'px')
        statusbar.style.setProperty('--pill-pad-expanded', basePad + 16 + 'px')
      }
      const highlightPMIDs = () => {
        const text = quill.getText()
        const len = quill.getLength()
        const selection = quill.getSelection()
        quill.formatText(0, len, 'pmid', false, 'silent')
        let match
        while ((match = pmidPattern.exec(text)) !== null) {
          const pmid = match[2] || match[3] || match[4] || match[5] || match[6]
          if (!pmid) continue
          quill.formatText(match.index, match[0].length, 'pmid', pmid, 'silent')
        }
        if (selection) quill.setSelection(selection.index, selection.length, 'silent')
      }
      const refresh = debounce(() => {
        highlightPMIDs()
        updateStats()
        ensureCaretBelowTop()
      }, 60)
      quill.on('text-change', refresh)
      quill.on('selection-change', () => {
        updateStats()
      })
      updateStats()
      highlightPMIDs()
    }

    const initPersistence = quill => {
      const STORAGE_KEY = 'abstract-atelier:content'
      let canPersist = true
      const save = debounce(() => {
        if (!canPersist) return
        try {
          const delta = quill.getContents()
          localStorage.setItem(STORAGE_KEY, JSON.stringify(delta))
        } catch (error) {
          canPersist = false
          console.warn('Unable to persist editor state', error)
        }
      }, 300)
      let stored = null
      try {
        stored = localStorage.getItem(STORAGE_KEY)
      } catch (error) {
        canPersist = false
        console.warn('Unable to access stored editor state', error)
      }
      if (stored) {
        try {
          const parsed = JSON.parse(stored)
          if (parsed && typeof parsed === 'object') {
            quill.setContents(parsed)
          }
        } catch (error) {
          console.warn('Stored editor state is invalid; clearing it', error)
          try {
            localStorage.removeItem(STORAGE_KEY)
          } catch (_) {}
        }
      }
      quill.on('text-change', () => {
        save()
      })
    }

    const fetchWithRetry = async (url, tries = 3) => {
      for (let i = 0; i < tries; i++) {
        try {
          const response = await fetch(url)
          if (!response.ok) throw new Error(String(response.status))
          return await response.text()
        } catch (error) {
          if (i === tries - 1) throw error
          await sleep(500 * (i + 1))
        }
      }
    }

    const initPopup = (quill, topbarEl) => {
      const popup = $('#popup')
      if (!popup) return
      let hideId = null
      let anchor = null
      const placePopup = rect => {
        const vw = innerWidth
        const vh = innerHeight
        const pad = 16
        const topbarBottom = topbarEl ? topbarEl.getBoundingClientRect().bottom : 0
        const width = Math.min(640, vw * 0.92)
        const height = Math.min(480, popup.offsetHeight || 300)
        let left = rect.left + rect.width / 2 - width / 2
        left = Math.max(pad, Math.min(left, vw - width - pad))
        let top = rect.bottom + pad
        const bottomLimit = vh - pad
        if (top + height > bottomLimit) {
          const aboveTop = rect.top - height - pad
          top = aboveTop >= topbarBottom + pad ? aboveTop : bottomLimit - height
        }
        top = Math.max(top, topbarBottom + pad)
        if (top + height > bottomLimit) top = Math.max(topbarBottom + pad, bottomLimit - height)
        popup.style.left = left + 'px'
        popup.style.top = top + 'px'
        popup.style.width = width + 'px'
        popup.style.maxHeight = '70vh'
      }
      const showPopup = async element => {
        const pmid = element.getAttribute('data-pmid')
        if (!pmid) return
        anchor = element
        popup.classList.remove('hidden')
        popup.innerHTML = '<div class="flex items-center gap-2 text-gray-600 dark:text-gray-300"><svg class="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg><span>Loading abstract</span></div>'
        placePopup(element.getBoundingClientRect())
        try {
          const url = 'https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=pubmed&id=' + pmid + '&rettype=abstract&retmode=xml'
          const xml = await fetchWithRetry(url)
          const doc = new DOMParser().parseFromString(xml, 'text/xml')
          const article = doc.querySelector('PubmedArticle')
          if (!article) throw new Error('No article')
          const title = article.querySelector('ArticleTitle')?.textContent || 'Title not found'
          const journal = article.querySelector('Title')?.textContent || ''
          const year = article.querySelector('PubDate Year')?.textContent || article.querySelector('ArticleDate Year')?.textContent || ''
          const vol = article.querySelector('Volume')?.textContent || ''
          const issue = article.querySelector('Issue')?.textContent || ''
          const pages = article.querySelector('MedlinePgn')?.textContent || ''
          const citation = [journal, year, vol + (issue ? '(' + issue + ')' : ''), pages].filter(Boolean).join(' ')
          let authors = [...article.querySelectorAll('Author')].map(author => {
            const last = author.querySelector('LastName')?.textContent || ''
            const initials = author.querySelector('Initials')?.textContent || ''
            return (last + ' ' + initials).trim()
          }).filter(Boolean).join(', ')
          if (!authors) authors = 'Authors not found'
          if (authors.length > 140) authors = authors.slice(0, 140) + '...'
          let abstract = ''
          const abstractNodes = article.querySelectorAll('AbstractText')
          if (abstractNodes.length) {
            abstract = [...abstractNodes].map(node => {
              const label = node.getAttribute('Label')
              const prefix = label ? '<strong>' + label + ':</strong> ' : ''
              return prefix + (node.textContent || '')
            }).join('<br><br>')
          }
          const abstractMarkup = abstract
            ? `<div class="abstract-box text-sm leading-relaxed nice-scroll max-h-60 overflow-y-auto rounded-lg px-3 py-3">${abstract}</div>`
            : ''
          const authorsSpacingClass = abstract ? 'mb-3' : 'mb-0'
          popup.innerHTML = `
        <div class="text-lg font-bold mb-1 leading-snug text-center">${title}</div>
        <div class="text-xs text-gray-500 dark:text-gray-400 mb-2 text-center">${citation}</div>
        <div class="text-sm text-gray-700 dark:text-gray-300 ${authorsSpacingClass} text-center">${authors}</div>
        ${abstractMarkup}
        <div class="mt-3 flex items-center justify-center text-gray-700 dark:text-gray-300">
          <a class="ql-pmid inline-flex items-center text-xs leading-none px-3 py-1" href="https://pubmed.ncbi.nlm.nih.gov/${pmid}/" target="_blank" rel="noopener noreferrer">PMID: ${pmid}</a>
        </div>
      `
          placePopup(element.getBoundingClientRect())
        } catch (error) {
          popup.innerHTML = '<div class="text-red-500">Error loading abstract</div>'
          placePopup(element.getBoundingClientRect())
        }
      }
      const hidePopup = () => {
        popup.classList.add('hidden')
        anchor = null
      }
      quill.root.addEventListener('mouseover', event => {
        const target = event.target.closest('.ql-pmid')
        if (!target) return
        clearTimeout(hideId)
        showPopup(target)
      })
      quill.root.addEventListener('mouseout', event => {
        const target = event.target.closest('.ql-pmid')
        if (!target) return
        hideId = setTimeout(hidePopup, 220)
      })
      popup.addEventListener('mouseenter', () => clearTimeout(hideId))
      popup.addEventListener('mouseleave', () => {
        hideId = setTimeout(hidePopup, 220)
      })
      window.addEventListener('scroll', () => {
        if (!popup.classList.contains('hidden') && anchor) placePopup(anchor.getBoundingClientRect())
      }, { passive: true })
      window.addEventListener('resize', () => {
        if (!popup.classList.contains('hidden') && anchor) placePopup(anchor.getBoundingClientRect())
      })
      // Clicks should behave like standard text selection; no special handling.
    }

    const init = () => {
      initThemeToggle()
      const { quill, toolbarEl } = initQuill()
      setupToolbarSnap(toolbarEl, quill)
      initExport(quill)
      initCopy(quill)
      const { ensureCaretBelowTop, topbarEl } = initLayout(quill)
      initStatsAndHighlighting(quill, ensureCaretBelowTop)
      initPersistence(quill)
      initPopup(quill, topbarEl)
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init, { once: true })
    } else {
      init()
    }
  })()
</script>
</body>
</html>
