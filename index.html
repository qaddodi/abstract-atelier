<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Abstract Atelier</title>
<!-- Tailwind CSS -->
<script src="https://cdn.tailwindcss.com"></script>
<script>
  tailwind.config = { darkMode: 'class' }
</script>
<!-- Fonts -->
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Fira+Mono:wght@500;700&display=swap" rel="stylesheet">
<link rel="icon" type="image/x-icon" href="icon.ico">
<!-- Quill CSS -->
<link href="https://cdn.jsdelivr.net/npm/quill@2.0.2/dist/quill.snow.css" rel="stylesheet">
<style>
  :root { --primary: #007aff; --toolbar-bg: rgba(255,255,255,.65); --toolbar-border: rgba(0,0,0,.06); --guide-line: rgba(15,23,42,.12); --toolbar-icon: #111827; --sidebar-gutter: clamp(0.75rem, 2.4vw, 1.35rem); --pmid-sidebar-width: 300px; --editor-track-max: 720px }
  .dark:root { --toolbar-bg: rgba(3,7,18,.65); --toolbar-border: rgba(255,255,255,.12); --guide-line: rgba(148,163,184,.22); --toolbar-icon: #f5f5f6 }
  body { font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background: #fdfcf7 }
  .dark body { background: #0b1120 }
  /* Smoothen theme transitions for key UI surfaces */
  /* :root, body, .ql-editor, #topbar, #statusbar, #popup, .infinite-fade-top, main::before, main::after {
    transition: background-color 5s ease, color .1s ease;
  } */
  /* Header title */
  .header-title { font-family: 'Fira Mono', monospace; letter-spacing: -0.02em }

  /* Quill base polishing */
  .ql-container { border: 0 !important; background: transparent }
  .ql-editor { font-size: 16px; line-height: 1.5; background: transparent; color: #111827; caret-color: #2563eb !important }
  .ql-editor p { margin-bottom: .5em }
  .ql-editor p:last-child { margin-bottom: 0 }
  .ql-container.ql-snow:focus-within,
  .ql-editor:focus,
  .ql-editor:focus-visible,
  .ql-editor:-moz-focusring { outline: none !important; box-shadow: none !important }
  .dark .ql-editor { color: #e5e7f5; caret-color: #93c5fd !important }
  .ql-editor a { text-decoration-color: rgba(37,99,235,.45) }
  .ql-editor a:hover { text-decoration-color: rgba(29,78,216,.6) }
  .ql-editor ol, .ql-editor ul { margin-bottom: .75em; padding-left: 1.25em }
  .ql-editor li { margin-bottom: .35em }
  #popup .ql-pmid { text-decoration: none; }
  #popup .ql-pmid:hover { text-decoration: none; }

  /* Toolbar translucent with shadows */
  #topbar { backdrop-filter: saturate(130%) blur(14px); -webkit-backdrop-filter: saturate(130%) blur(14px); background: var(--toolbar-bg); border-color: var(--toolbar-border); box-shadow: none; }

  /* FLOATING STATUSBAR PILL */
  #statusbar { position: fixed; left: 50%; bottom: 16px; transform: translateX(-50%); z-index: 60; display: inline-flex; align-items: center; justify-content: center; gap: 14px; padding: 10px var(--pill-pad, 16px); border-radius: 9999px; border: 1px solid var(--toolbar-border); backdrop-filter: saturate(120%) blur(12px); -webkit-backdrop-filter: saturate(120%) blur(12px); background: var(--toolbar-bg); box-shadow: 0 10px 30px rgba(0,0,0,.18), 0 2px 6px rgba(0,0,0,.12); flex-wrap: nowrap; transition: padding .25s ease }
  #statusbar:hover, #statusbar:focus-within { padding: 10px var(--pill-pad-expanded, calc(var(--pill-pad, 16px) + 12px)) }
  .dark #statusbar { box-shadow: 0 14px 36px rgba(0,0,0,.5), 0 2px 8px rgba(0,0,0,.45) }
  #statusbar span { white-space: nowrap }
  #statusbar .stat { display: inline-flex; align-items: center; gap: 6px; font-variant-numeric: tabular-nums }
  #statusbar .stat svg { flex-shrink: 0 }
  #statusbar .stat { position: relative }
  #statusbar .stat-label { opacity: 0; font-size: .65rem; letter-spacing: .04em; text-transform: uppercase; color: inherit; max-width: 0; overflow: hidden; margin-left: 0; transition: opacity .22s ease, transform .22s ease, max-width .22s ease, margin-left .22s ease; transform: translateY(4px) }
  #statusbar:hover .stat-label,
  #statusbar:focus-within .stat-label { opacity: .75; transform: translateY(0); max-width: 40px; margin-left: 4px }
  #statusbar .stat-total { font-weight: 600 }

  /* Quill toolbar visuals */
  /* Quill will add .ql-toolbar automatically to #toolbar after initialization */
  .ql-toolbar.ql-snow { box-shadow: none; border-radius: 9999px; }
  .ql-toolbar { border: 0 !important; background: transparent !important; display: flex; align-items: center; justify-content: center; gap: .5rem; overflow-x: auto; overflow-y: hidden; white-space: nowrap; flex-wrap: nowrap; scrollbar-width: thin; -webkit-overflow-scrolling: touch }
  .ql-toolbar .ql-formats { margin: 0; flex-shrink: 0; display: inline-flex; align-items: center; gap: .5rem }
  .ql-toolbar button, .ql-toolbar .ql-picker { height: 26px; flex-shrink: 0 }
  .ql-toolbar .ql-picker-label, .ql-toolbar button { display: inline-flex; align-items: center }
  .ql-toolbar .ql-stroke { stroke: #111827 }
  .ql-toolbar .ql-fill { fill: #111827 }
  .dark .ql-toolbar .ql-stroke { stroke: #f5f5f6 }
  .dark .ql-toolbar .ql-fill { fill: #f5f5f6 }
  .ql-custom-btn { border: none; border-radius: 3px; width: 28px; height: 28px; display: inline-flex; align-items: center; justify-content: center; cursor: pointer; padding: 0; color: var(--toolbar-icon); background: transparent }
  .ql-custom-btn svg { pointer-events: none }
  .ql-custom-btn:hover, .ql-custom-btn:focus-visible { color: rgba(59,130,246,1); outline: none }
  .ql-custom-btn.ql-active { color: rgba(29,78,216,1) }
  .dark .ql-custom-btn { background: transparent }
  .dark .ql-custom-btn:hover, .dark .ql-custom-btn:focus-visible { color: rgba(191,219,254,1) }
  .dark .ql-custom-btn.ql-active { color: rgba(147,197,253,1) }
  @media (max-width: 640px) {
    .ql-toolbar { justify-content: flex-start }
  }

  /* PMID token */
  .ql-pmid { background: #dbeafe; color: var(--primary); border-radius: 6px; padding: 1px 6px; font-weight: 700; cursor: pointer; white-space: nowrap; transition: color .18s ease, background-color .18s ease, text-decoration-color .18s ease }
  .dark .ql-pmid { background: #1e3a8a; color: #93c5fd }

  /* Editor host and infinite look */
  #editor-card { position: relative; width: 100%; max-width: var(--editor-track-max); margin-left: 0; margin-right: auto; border: 0 !important; box-shadow: none !important; background: transparent; overflow: clip }
  #editor-card::before,
  #editor-card::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    width: 2px;
    pointer-events: none;
    background: linear-gradient(to bottom, transparent 0%, var(--guide-line) 14%, var(--guide-line) 86%, transparent 100%);
    opacity: .6;
  }
  #editor-card::before { left: 0 }
  #editor-card::after { right: 0 }
  #editor-shell { min-height: 0 }

  /* Top and bottom fades to imply infinite page */
  .infinite-fade-top { display: none }
  .dark .infinite-fade-top { display: none }

  /* Popup - translucent glass */
  #popup { position: fixed; max-width: 640px; width: 92vw; background: rgba(255,255,255,.78); border: 1px solid rgba(0,0,0,.06); border-radius: 14px; backdrop-filter: saturate(120%) blur(10px); -webkit-backdrop-filter: saturate(120%) blur(10px); box-shadow: 0 20px 50px rgba(0,0,0,.25); z-index: 70 }
  .dark #popup { background: rgba(2,6,23,.78); border-color: rgba(255,255,255,.12); color: #e5e7eb; box-shadow: 0 20px 50px rgba(0,0,0,.5) }
  #popup .abstract-box { border: 1px solid var(--toolbar-border); background: rgba(255,255,255,.55); }
  .dark #popup .abstract-box { border-color: var(--toolbar-border); background: rgba(15,23,42,.45); }
  .nice-scroll { scrollbar-width: thin; scrollbar-color: rgba(148,163,184,.45) transparent }
  .nice-scroll::-webkit-scrollbar { width: 6px; height: 6px }
  .nice-scroll::-webkit-scrollbar-track { background: transparent; margin: 10px 0 }
  .nice-scroll::-webkit-scrollbar-thumb { background-color: rgba(148,163,184,.45); border-radius: 9999px; border: 1px solid transparent }
  .nice-scroll:hover::-webkit-scrollbar-thumb { background-color: rgba(148,163,184,.65) }
  .dark .nice-scroll { scrollbar-color: rgba(209,213,219,.55) transparent }
  .dark .nice-scroll::-webkit-scrollbar-thumb { background-color: rgba(203,213,225,.5) }
  .dark .nice-scroll:hover::-webkit-scrollbar-thumb { background-color: rgba(226,232,240,.75) }
  #pmid-sidebar { display: flex; flex-direction: column; position: sticky; top: calc((var(--topbar-height, 0px)) + 24px); max-height: calc(100vh - (var(--topbar-height, 0px) + 72px)); min-height: 220px; width: var(--pmid-sidebar-width); margin-left: var(--sidebar-gutter); margin-right: var(--sidebar-gutter); padding: 22px; border-radius: 20px; border: 1px solid rgba(15,23,42,.08); background: rgba(255,255,255,.72); backdrop-filter: saturate(130%) blur(18px); -webkit-backdrop-filter: saturate(130%) blur(18px); box-shadow: 0 18px 46px rgba(15,23,42,.14); overflow-y: auto; overflow-x: hidden; transition: border-color .2s ease, box-shadow .2s ease, background-color .2s ease, margin-left .32s ease, margin-right .32s ease, transform .32s ease, opacity .22s ease }
  .dark #pmid-sidebar { border-color: rgba(148,163,184,.22); background: rgba(15,23,42,.68); box-shadow: 0 24px 60px rgba(0,0,0,.55) }
  #pmid-sidebar { scrollbar-gutter: stable both-edges }
  #pmid-sidebar::-webkit-scrollbar { width: 6px }
  #pmid-sidebar::-webkit-scrollbar-track { background: transparent; margin: 12px 0 }
  #pmid-sidebar::-webkit-scrollbar-thumb { background-color: rgba(100,116,139,.45); border-radius: 9999px; border: 1px solid transparent }
  #pmid-sidebar:hover::-webkit-scrollbar-thumb { background-color: rgba(100,116,139,.65) }
  .dark #pmid-sidebar::-webkit-scrollbar-thumb { background-color: rgba(148,163,184,.45) }
  .dark #pmid-sidebar:hover::-webkit-scrollbar-thumb { background-color: rgba(191,202,220,.75) }
  .pmid-sidebar-header { display: flex; flex-direction: column; align-items: center; gap: 6px; margin-bottom: 16px; text-align: center }
  .pmid-sidebar-title { display: inline-flex; align-items: baseline; justify-content: center; gap: .45rem; font-size: .8rem; font-weight: 700; text-transform: uppercase; color: #0f172a }
  .pmid-sidebar-title-label { letter-spacing: .26em }
  .dark .pmid-sidebar-title { color: #f8fafc }
  .pmid-sidebar-count { font-size: .68rem; color: #64748b; letter-spacing: .12em; margin-left: .1rem }
  .dark .pmid-sidebar-count { color: #94a3b8 }
  #pmid-card-list { display: flex; flex-direction: column; gap: 14px }
  .pmid-empty-state { font-size: .75rem; color: #64748b; text-align: center; line-height: 1.4; margin-top: 24px }
  .dark .pmid-empty-state { color: #a1accf }
  .pmid-card { position: relative; display: block; padding: 12px 14px; border-radius: 16px; border: 1px solid rgba(15,23,42,.08); background: #ffffff; transition: transform .18s ease, border-color .18s ease, box-shadow .18s ease; cursor: pointer; text-align: left; appearance: none; -webkit-appearance: none; font-size: .72rem; overflow: visible }
  .pmid-card:hover, .pmid-card.is-hovered, .pmid-card:focus-visible { border-color: rgba(220,38,38,.65); background: rgba(254,226,226,.95); outline: none }
  .dark .pmid-card { border-color: rgba(148,163,184,.15); background: rgba(15,23,42,.92) }
  .dark .pmid-card:hover, .dark .pmid-card.is-hovered, .dark .pmid-card:focus-visible { border-color: rgba(248,113,113,.65); background: rgba(127,29,29,.5) }
  .pmid-card-body { display: flex; flex-direction: column; gap: 6px; position: relative; z-index: 2 }
  .pmid-card-layers { position: absolute; inset: 0; border-radius: inherit; pointer-events: none; z-index: -1 }
  .pmid-card-layer { position: absolute; inset: 0; border-radius: inherit; border: 1px solid rgba(15,23,42,.08); background: #ffffff; transform: translate(0, 0); opacity: 1; box-shadow: 0 8px 18px rgba(15,23,42,.08); transition: transform .2s ease, border-color .2s ease }
  .pmid-card-layer.layer-1 { transform: translateY(4px); background: #ffffff; border-color: rgba(15,23,42,.1); opacity: .92; z-index: 30 }
  .pmid-card-layer.layer-2 { transform: translateY(8px); background: #f6f8fc; border-color: rgba(15,23,42,.07); opacity: .75; z-index: 20 }
  .pmid-card-layer.layer-3 { transform: translateY(12px); background: #eef1f7; border-color: rgba(15,23,42,.05); opacity: .58; z-index: 10 }
  .pmid-card:hover .pmid-card-layer,
  .pmid-card.is-hovered .pmid-card-layer,
  .pmid-card:focus-visible .pmid-card-layer { border-color: rgba(220,38,38,.28) }
  .pmid-card:hover .pmid-card-layer.layer-1,
  .pmid-card.is-hovered .pmid-card-layer.layer-1,
  .pmid-card:focus-visible .pmid-card-layer.layer-1 { background: rgba(254,226,226,.95) }
  .pmid-card-count { position: absolute; top: 10px; right: 12px; display: none; align-items: center; justify-content: center; padding: 2px 7px; border-radius: 9999px; font-size: .6rem; font-weight: 700; letter-spacing: .08em; background: rgba(59,130,246,.12); color: #1d4ed8; text-transform: uppercase }
  .pmid-card-count.is-visible { display: inline-flex }
  .dark .pmid-card-layers { z-index: -1 }
  .dark .pmid-card-layer { border: 1px solid rgba(148,163,184,.18); background: #111827; box-shadow: 0 8px 20px rgba(0,0,0,.45) }
  .dark .pmid-card-layer.layer-1 { background: #111827; border-color: rgba(148,163,184,.2); opacity: .92; z-index: 30 }
  .dark .pmid-card-layer.layer-2 { background: #141c2f; border-color: rgba(148,163,184,.14); opacity: .72; z-index: 20 }
  .dark .pmid-card-layer.layer-3 { background: #0f1725; border-color: rgba(148,163,184,.1); opacity: .55; z-index: 10 }
  .dark .pmid-card:hover .pmid-card-layer,
  .dark .pmid-card.is-hovered .pmid-card-layer,
  .dark .pmid-card:focus-visible .pmid-card-layer { border-color: rgba(248,113,113,.3) }
  .dark .pmid-card:hover .pmid-card-layer.layer-1,
  .dark .pmid-card.is-hovered .pmid-card-layer.layer-1,
  .dark .pmid-card:focus-visible .pmid-card-layer.layer-1 { background: rgba(127,29,29,.5) }
  .dark .pmid-card-count { background: rgba(96,165,250,.24); color: #bfdbfe }
  .pmid-card-meta { display: flex; align-items: center; gap: 6px; font-size: .58rem; text-transform: uppercase; letter-spacing: .18em; color: #0f172a; opacity: .7; flex-wrap: wrap }
  .pmid-card-title { font-size: .74rem; font-weight: 600; line-height: 1.3; color: #0f172a }
  .pmid-card-journal { font-size: .62rem; color: #475569; letter-spacing: .1em; text-transform: uppercase }
  .pmid-card-loading { font-size: .62rem; color: #64748b }
  .pmid-card-error { font-size: .62rem; color: #dc2626 }
  .dark .pmid-card-title { color: #f1f5f9 }
  .dark .pmid-card-meta { color: #e2e8f0 }
  .dark .pmid-card-journal { color: #a5b4fc }
  .dark .pmid-card-loading { color: #cbd5f5 }
  .dark .pmid-card-error { color: #fca5a5 }
  .pmid-inline-highlight { color: #dc2626 !important; background: rgba(254,226,226,.95) !important }
  .dark .pmid-inline-highlight { color: #f87171 !important; background: rgba(127,29,29,.5) !important }
  #workspace-shell { --workspace-gap: 1.5rem; --editor-min-width: 320px; --pmid-sidebar-total: calc(var(--pmid-sidebar-width) + (var(--sidebar-gutter) * 2)); --pmid-sidebar-track: calc(var(--pmid-sidebar-total) + var(--workspace-gap)); transition: padding .32s ease; }
  #workspace-shell > .flex-1 {
    flex: 0 0 max(var(--editor-min-width), calc(100% - var(--pmid-sidebar-track)));
    width: max(var(--editor-min-width), calc(100% - var(--pmid-sidebar-track)));
    max-width: max(var(--editor-min-width), calc(100% - var(--pmid-sidebar-track)));
    margin-left: 0;
    margin-right: 0;
    transition: margin .32s ease, max-width .32s ease;
  }
  body.pmid-sidebar-collapsed #pmid-sidebar { opacity: 0; transform: translateX(-32px); margin-left: 0; margin-right: calc(-1 * var(--pmid-sidebar-track)); pointer-events: none }
  body.pmid-sidebar-collapsed #editor-card { margin-left: auto; margin-right: auto }
  body.pmid-sidebar-collapsed #workspace-shell > .flex-1 {
    margin-left: calc(var(--pmid-sidebar-track) / 2);
    margin-right: calc(var(--pmid-sidebar-track) / 2);
  }
  body:not(.pmid-sidebar-ready) #pmid-sidebar,
  body:not(.pmid-sidebar-ready) #workspace-shell > .flex-1 { transition: none !important }
  @media (max-width: 767px) {
    #pmid-sidebar { display: none }
    #toggle-sidebar { display: none }
    #editor-card { margin-left: auto; margin-right: auto }
    #workspace-shell > .flex-1 { flex: 1 1 auto; width: 100%; max-width: 100%; margin: 0 !important }
  }
</style>
</head>
<body class="antialiased bg-gray-50 dark:bg-gray-950 text-gray-900 dark:text-gray-100 min-h-screen selection:bg-blue-200 dark:selection:bg-blue-900">

<!-- Top bar: Title + Theme toggle + Quill toolbar (centered) -->
<div id="topbar" class="fixed top-0 inset-x-0 z-50 border-b">
  <div class="max-w-7xl mx-auto px-4">
    <div class="py-3 flex flex-col items-center justify-center gap-1.5">
      <h1 class="header-title text-xl font-bold text-stone-700 dark:text-stone-100">Abstract Atelier</h1>
      <p class="italic text-xs text-stone-500 dark:text-stone-300">by Mohammad Almeqdadi, MD</p>
    </div>
  </div>
  <!-- Important: Use a dedicated toolbar container with a stable id. Do NOT pre-apply .ql-toolbar -->
  <div id="toolbar">
    <span class="ql-formats">
      <button id="theme-toggle" type="button" aria-label="Toggle theme" class="ql-custom-btn ql-theme-btn"></button>
      <button id="toggle-sidebar" type="button" aria-label="Hide citations panel" aria-controls="pmid-sidebar" aria-expanded="true" class="ql-custom-btn">
        <svg id="sidebar-icon" xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 transition-transform duration-200" viewBox="0 0 24 24" fill="currentColor">
          <path fill-rule="evenodd" clip-rule="evenodd" d="M9.94531 1.25H14.0551C15.4227 1.24998 16.525 1.24996 17.3919 1.36652C18.292 1.48754 19.0499 1.74643 19.6518 2.34835C20.2538 2.95027 20.5126 3.70814 20.6337 4.60825C20.7502 5.47522 20.7502 6.57754 20.7502 7.94513V16.0549C20.7502 17.4225 20.7502 18.5248 20.6337 19.3918C20.5126 20.2919 20.2538 21.0497 19.6518 21.6517C19.0499 22.2536 18.292 22.5125 17.3919 22.6335C16.525 22.75 15.4226 22.75 14.0551 22.75H9.94532C8.57773 22.75 7.4754 22.75 6.60844 22.6335C5.70833 22.5125 4.95045 22.2536 4.34854 21.6517C3.74662 21.0497 3.48773 20.2919 3.36671 19.3918C3.32801 19.1039 3.30216 18.7902 3.2849 18.4494C3.24582 18.326 3.23821 18.1912 3.26895 18.0568C3.25016 17.4649 3.25017 16.7991 3.25019 16.0549V7.94513C3.25017 6.57754 3.25015 5.47522 3.36671 4.60825C3.48773 3.70814 3.74662 2.95027 4.34854 2.34835C4.95045 1.74643 5.70833 1.48754 6.60843 1.36652C7.4754 1.24996 8.57772 1.24998 9.94531 1.25ZM4.77694 18.2491C4.79214 18.6029 4.81597 18.914 4.85333 19.1919C4.95199 19.9257 5.13243 20.3142 5.4092 20.591C5.68596 20.8678 6.07453 21.0482 6.80831 21.1469C7.56366 21.2484 8.56477 21.25 10.0002 21.25H14.0002C15.4356 21.25 16.4367 21.2484 17.1921 21.1469C17.9258 21.0482 18.3144 20.8678 18.5912 20.591C18.7875 20.3947 18.9353 20.1421 19.0399 19.75H8.00019C7.58597 19.75 7.25019 19.4142 7.25019 19C7.25019 18.5858 7.58597 18.25 8.00019 18.25H19.2234C19.2419 17.819 19.2477 17.3246 19.2494 16.75H7.89796C6.91971 16.75 6.5777 16.7564 6.31562 16.8267C5.5963 17.0194 5.02286 17.5541 4.77694 18.2491ZM19.2502 15.25H7.89796C7.85879 15.25 7.8202 15.25 7.78217 15.25C6.9642 15.2497 6.40605 15.2495 5.92739 15.3778C5.49941 15.4925 5.10242 15.6798 4.75019 15.9259V8C4.75019 6.56458 4.75178 5.56347 4.85333 4.80812C4.95199 4.07435 5.13243 3.68577 5.4092 3.40901C5.68596 3.13225 6.07453 2.9518 6.80831 2.85315C7.56366 2.75159 8.56477 2.75 10.0002 2.75H14.0002C15.4356 2.75 16.4367 2.75159 17.1921 2.85315C17.9258 2.9518 18.3144 3.13225 18.5912 3.40901C18.8679 3.68577 19.0484 4.07435 19.147 4.80812C19.2486 5.56347 19.2502 6.56458 19.2502 8V15.25ZM7.25019 7C7.25019 6.58579 7.58597 6.25 8.00019 6.25H16.0002C16.4144 6.25 16.7502 6.58579 16.7502 7C16.7502 7.41421 16.4144 7.75 16.0002 7.75H8.00019C7.58597 7.75 7.25019 7.41421 7.25019 7ZM7.25019 10.5C7.25019 10.0858 7.58597 9.75 8.00019 9.75H13.0002C13.4144 9.75 13.7502 10.0858 13.7502 10.5C13.7502 10.9142 13.4144 11.25 13.0002 11.25H8.00019C7.58597 11.25 7.25019 10.9142 7.25019 10.5Z" fill="currentColor"></path>
        </svg>
      </button>
      <button id="copy-html" type="button" aria-label="Copy as HTML" class="ql-custom-btn">
        <svg id="copy-icon" xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 transition-transform duration-200" viewBox="0 0 24 24" fill="currentColor">
          <path d="M16 1H4a2 2 0 0 0-2 2v14h2V3h12V1zm3 4H8a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2zm-1 16H8V7h11v14z"/>
        </svg>
      </button>
      <button id="export-pdf" type="button" aria-label="Export to PDF" class="ql-custom-btn">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
          <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
        </svg>
      </button>
    </span>
    <span class="ql-formats">
      <button class="ql-bold"></button>
      <button class="ql-italic"></button>
      <button class="ql-underline"></button>
    </span>
    <span class="ql-formats">
      <button class="ql-align" value=""></button>
      <button class="ql-align" value="center"></button>
      <button class="ql-align" value="justify"></button>
    </span>
    <span class="ql-formats">
      <button class="ql-list" value="ordered"></button>
      <button class="ql-list" value="bullet"></button>
    </span>
    <span class="ql-formats">
      <button class="ql-clean"></button>
    </span>
  </div>
</div>

<!-- Main -->
<main class="max-w-6xl mx-auto px-4 md:px-8 pt-28 pb-12 overflow-visible">
  <div id="workspace-shell" class="flex flex-col md:flex-row md:items-start gap-6">
    <aside id="pmid-sidebar" class="nice-scroll" aria-label="PMID citations panel">
      <div class="pmid-sidebar-header">
        <span class="pmid-sidebar-title">
          <span class="pmid-sidebar-title-label">CITATIONS</span>
          <span id="pmid-sidebar-count" class="pmid-sidebar-count" aria-live="polite">0</span>
        </span>
      </div>
      <div id="pmid-card-list"></div>
      <div id="pmid-sidebar-empty" class="pmid-empty-state">Add a PMID citation in your text to see it here.</div>
    </aside>
    <div class="flex-1 min-w-0">
      <div id="editor-card">
        <div id="editor-shell">
          <div id="editor"></div>
        </div>
      </div>
    </div>
  </div>
</main>
<div class="infinite-fade-top"></div>

<!-- Floating status pill -->
<div id="statusbar" class="text-sm text-gray-700 dark:text-gray-300" role="status" aria-live="polite">
  <span class="stat" id="s-words" data-label="Words" aria-label="Words 0">
    <svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.6" class="h-4 w-4">
      <path d="M4 5h12M4 10h9M4 15h8" stroke-linecap="round"/>
    </svg>
    <span class="stat-label" aria-hidden="true">Words</span>
    <span class="stat-text">0</span>
  </span>
  <span class="separator">•</span>
  <span class="stat" id="s-chars" data-label="Chars" aria-label="Chars 0">
    <svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.6" class="h-4 w-4">
      <path d="M5 15L10 5l5 10M7 13h6" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
    <span class="stat-label" aria-hidden="true">Chars</span>
    <span class="stat-text">0</span>
  </span>
  <span class="separator">•</span>
  <span class="stat" id="s-pmids" data-label="PMIDs" aria-label="PMIDs 0">
    <svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.6" class="h-4 w-4">
      <path d="M6 4h6l3 3v9H6z" stroke-linejoin="round"/>
      <path d="M12 4v3h3" stroke-linejoin="round"/>
      <path d="M8 9h5M8 12h5M8 15h5" stroke-linecap="round"/>
    </svg>
    <span class="stat-label" aria-hidden="true">PMIDs</span>
    <span class="stat-text">0</span>
  </span>
</div>

<!-- Popup -->
<div id="popup" class="hidden p-4 shadow-2xl"></div>

<!-- Quill JS -->
<script src="https://cdn.jsdelivr.net/npm/quill@2.0.2/dist/quill.js"></script>
<script>
  (() => {
    // Constants
    const PMID_PATTERN = /(\[\s*PMID\s*:\s*(\d{7,9})\s*\])|(?:PMID\s*:\s*(\d{7,9}))|(?:PMID\s+(\d{7,9}))|(?:PMID(\d{7,9}))|\b(\d{7,9})\b/g;
    const ICONS = {
      sun: '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="M4.93 4.93l1.41 1.41"/><path d="M17.66 17.66l1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="M6.34 17.66l-1.41 1.41"/><path d="M19.07 4.93l-1.41 1.41"/></svg>',
      moon: '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>'
    };
    const STORAGE_KEYS = {
      theme: 'theme',
      sidebar: 'abstract-atelier:sidebar-visibility',
      content: 'abstract-atelier:content'
    };

    // Utilities
    const $ = (selector, scope = document) => scope.querySelector(selector);
    const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));
    const debounce = (fn, delay = 120) => {
      let id;
      return (...args) => {
        clearTimeout(id);
        id = setTimeout(() => fn(...args), delay);
      };
    };
    const easeOutCubic = t => 1 - Math.pow(1 - t, 3);
    let cancelActiveScroll = null;
    const animateScrollTo = (scroller, destination, { isDocument, duration = 520, easing = easeOutCubic } = {}) => {
      if (!Number.isFinite(destination)) return;
      const prefersReduced = window.matchMedia?.('(prefers-reduced-motion: reduce)')?.matches;
      const docEl = document.scrollingElement || document.documentElement || document.body;
      const targetEl = isDocument ? docEl : scroller;
      if (!targetEl) return;
      if (cancelActiveScroll) cancelActiveScroll();
      if (prefersReduced || typeof window.requestAnimationFrame !== 'function') {
        if (isDocument) {
          window.scrollTo(0, destination);
          if (docEl) docEl.scrollTop = destination;
          if (document.body) document.body.scrollTop = destination;
        } else {
          targetEl.scrollTop = destination;
        }
        cancelActiveScroll = null;
        return;
      }
      const raf = window.requestAnimationFrame.bind(window);
      const caf = window.cancelAnimationFrame.bind(window);
      const now = () => (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      const start = isDocument
        ? (window.scrollY ?? window.pageYOffset ?? docEl?.scrollTop ?? document.body?.scrollTop ?? 0)
        : (targetEl.scrollTop || 0);
      const distance = destination - start;
      if (Math.abs(distance) < 1) {
        if (isDocument) {
          window.scrollTo(0, destination);
          if (docEl) docEl.scrollTop = destination;
          if (document.body) document.body.scrollTop = destination;
        } else {
          targetEl.scrollTop = destination;
        }
        cancelActiveScroll = null;
        return;
      }
      const startTime = now();
      let rafId = null;
      const cancel = () => {
        if (rafId !== null) caf(rafId);
        cancelActiveScroll = null;
      };
      const step = timestamp => {
        const elapsed = duration > 0 ? Math.min(1, (timestamp - startTime) / duration) : 1;
        const progress = easing ? easing(elapsed) : elapsed;
        const value = start + (distance * progress);
        if (isDocument) {
          window.scrollTo(0, value);
          if (docEl) docEl.scrollTop = value;
          if (document.body) document.body.scrollTop = value;
        } else {
          targetEl.scrollTop = value;
        }
        if (elapsed < 1) {
          rafId = raf(step);
        } else {
          if (isDocument) {
            window.scrollTo(0, destination);
            if (docEl) docEl.scrollTop = destination;
            if (document.body) document.body.scrollTop = destination;
          } else {
            targetEl.scrollTop = destination;
          }
          cancel();
        }
      };
      cancelActiveScroll = cancel;
      rafId = raf(step);
    };
    const fetchWithRetry = async (url, tries = 3) => {
      for (let i = 0; i < tries; i++) {
        try {
          const response = await fetch(url);
          if (!response.ok) throw new Error(String(response.status));
          return await response.text();
        } catch (error) {
          if (i === tries - 1) throw error;
          await sleep(500 * (i + 1));
        }
      }
    };

    // PMID Utilities
    const pmidMetadataCache = new Map();
    const metadataQueue = [];
    let metadataWorkerActive = false;

    const processMetadataQueue = () => {
      if (metadataWorkerActive) return;
      const next = metadataQueue.shift();
      if (!next) return;
      metadataWorkerActive = true;
      const { pmid, resolve, reject, attempt } = next;
      fetchPmidMetadataNow(pmid)
        .then(data => resolve(data))
        .catch(error => {
          if (attempt < 2) {
            metadataQueue.push({ pmid, resolve, reject, attempt: attempt + 1 });
          } else {
            reject(error);
          }
        })
        .finally(() => {
          metadataWorkerActive = false;
          setTimeout(processMetadataQueue, 360);
        });
    };

    const enqueueMetadataFetch = pmid => new Promise((resolve, reject) => {
      metadataQueue.push({ pmid, resolve, reject, attempt: 0 });
      processMetadataQueue();
    });

    const extractUniquePMIDs = text => {
      if (!text) return [];
      const seen = new Set();
      const ordered = [];
      PMID_PATTERN.lastIndex = 0;
      let match;
      while ((match = PMID_PATTERN.exec(text)) !== null) {
        const value = match[2] || match[3] || match[4] || match[5] || match[6];
        if (value && !seen.has(value)) {
          seen.add(value);
          ordered.push(value);
        }
      }
      return ordered;
    };

    const countPMIDMentions = text => {
      const counts = new Map();
      if (!text) return counts;
      PMID_PATTERN.lastIndex = 0;
      let match;
      while ((match = PMID_PATTERN.exec(text)) !== null) {
        const value = match[2] || match[3] || match[4] || match[5] || match[6];
        if (!value) continue;
        counts.set(value, (counts.get(value) || 0) + 1);
      }
      return counts;
    };

    const fetchPmidMetadataNow = async pmid => {
      const url = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=pubmed&id=${pmid}&rettype=abstract&retmode=xml`;
      const xml = await fetchWithRetry(url);
      const doc = new DOMParser().parseFromString(xml, 'text/xml');
      const article = doc.querySelector('PubmedArticle');
      if (!article) throw new Error(`No article data for PMID ${pmid}`);
      const getText = selector => article.querySelector(selector)?.textContent?.trim() || '';
      const title = getText('ArticleTitle') || 'Title not found';
      const journalTitle = getText('Journal > Title');
      const journalAbbrev = getText('MedlineTA') || getText('ISOAbbreviation') || journalTitle;
      const yearRaw = getText('Journal > JournalIssue > PubDate > Year') || getText('ArticleDate > Year');
      const medlineDate = getText('Journal > JournalIssue > PubDate > MedlineDate');
      const yearFallback = medlineDate ? ((medlineDate.match(/\d{4}/) || [])[0] || '') : '';
      const year = yearRaw || yearFallback;
      const volume = getText('Journal > JournalIssue > Volume');
      const issue = getText('Journal > JournalIssue > Issue');
      const pages = getText('Article > Pagination > MedlinePgn');
      const authorNodes = article.querySelectorAll('AuthorList > Author');
      const authors = [...authorNodes].map(author => {
        const last = author.querySelector('LastName')?.textContent?.trim() || '';
        const initials = author.querySelector('Initials')?.textContent?.trim() || '';
        return (last + (initials ? ' ' + initials : '')).trim();
      }).filter(Boolean);
      const authorsFull = authors.length ? authors.join(', ') : 'Authors not found';
      let authorsDisplay = authorsFull;
      if (authorsDisplay.length > 140) authorsDisplay = authorsDisplay.slice(0, 137) + '...';
      const abstractNodes = article.querySelectorAll('AbstractText');
      const abstractSegments = [...abstractNodes].map(node => {
        const label = node.getAttribute('Label');
        const prefix = label ? `<strong>${label}:</strong> ` : '';
        return prefix + (node.textContent || '').trim();
      }).filter(Boolean);
      const abstractHtml = abstractSegments.join('<br><br>');
      const citeVolume = volume ? volume + (issue ? `(${issue})` : '') : '';
      const citationParts = [journalAbbrev || journalTitle, year, citeVolume, pages].filter(Boolean);
      return {
        pmid,
        title,
        journalTitle,
        journalAbbrev,
        year,
        volume,
        issue,
        pages,
        citation: citationParts.join(' '),
        authorsFull,
        authorsDisplay,
        abstractHtml
      };
    };

    const fetchPmidMetadata = pmid => {
      if (!pmid) return Promise.reject(new Error('Invalid PMID'));
      if (pmidMetadataCache.has(pmid)) return pmidMetadataCache.get(pmid);
      const promise = enqueueMetadataFetch(pmid);
      pmidMetadataCache.set(pmid, promise);
      promise.catch(() => pmidMetadataCache.delete(pmid));
      return promise;
    };

    const createAnchorForPMID = node => {
      const pmid = node.getAttribute('data-pmid') || (node.textContent.match(/\d{7,9}/) || [])[0];
      if (!pmid) return;
      const anchor = document.createElement('a');
      anchor.href = `https://pubmed.ncbi.nlm.nih.gov/${pmid}/`;
      anchor.textContent = node.textContent;
      anchor.target = '_blank';
      anchor.rel = 'noopener noreferrer';
      node.replaceWith(anchor);
    };

    // Quill Extensions
    const registerQuillExtensions = () => {
      const Inline = Quill.import('blots/inline');
      class PMIDBlot extends Inline {
        static create(value) {
          const node = super.create();
          if (value && value !== true) node.setAttribute('data-pmid', value);
          node.classList.add('ql-pmid');
          return node;
        }
        static formats(node) {
          return node.getAttribute('data-pmid') || false;
        }
      }
      PMIDBlot.blotName = 'pmid';
      PMIDBlot.tagName = 'span';
      Quill.register(PMIDBlot, true);

      const Size = Quill.import('attributors/style/size');
      Size.whitelist = ['12px', '14px', '16px', '18px', '20px', '22px', '24px', '26px', '28px'];
      Quill.register(Size, true);
    };

    // Initialization Modules
    const initThemeToggle = () => {
      const root = document.documentElement;
      const body = document.body;
      const btn = $('#theme-toggle');
      if (!btn) return;
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const storedTheme = localStorage.getItem(STORAGE_KEYS.theme);
      let isDark = storedTheme ? storedTheme === 'dark' : prefersDark;
      const render = () => {
        root.classList.toggle('dark', isDark);
        body.classList.toggle('dark', isDark);
        btn.innerHTML = isDark ? ICONS.sun : ICONS.moon;
        btn.classList.remove('ql-active');
      };
      render();
      requestAnimationFrame(() => {
        document.body.classList.add('pmid-sidebar-ready');
      });
      btn.addEventListener('click', () => {
        isDark = !root.classList.contains('dark');
        render();
        localStorage.setItem(STORAGE_KEYS.theme, isDark ? 'dark' : 'light');
      });
    };

    const initSidebarToggle = sidebar => {
      const btn = $('#toggle-sidebar');
      const icon = $('#sidebar-icon');
      if (!btn || !sidebar) return;
      const readStoredState = () => {
        try {
          return localStorage.getItem(STORAGE_KEYS.sidebar) === 'collapsed';
        } catch (_) {
          return false;
        }
      };
      let collapsed = readStoredState();
      const render = () => {
        document.body.classList.toggle('pmid-sidebar-collapsed', collapsed);
        sidebar.setAttribute('aria-hidden', collapsed ? 'true' : 'false');
        btn.setAttribute('aria-label', collapsed ? 'Show citations panel' : 'Hide citations panel');
        btn.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
        btn.classList.toggle('ql-active', !collapsed);
        if (icon) icon.classList.toggle('opacity-80', collapsed);
      };
      render();
      if (window.matchMedia('(max-width: 767px)').matches) {
        collapsed = true;
        render();
      }
      btn.addEventListener('click', () => {
        collapsed = !collapsed;
        render();
        try {
          localStorage.setItem(STORAGE_KEYS.sidebar, collapsed ? 'collapsed' : 'expanded');
        } catch (_) {}
      });
      const mq = window.matchMedia('(max-width: 767px)');
      const handleMedia = event => {
        if (!event.matches) return;
        collapsed = true;
        render();
      };
      mq.addEventListener ? mq.addEventListener('change', handleMedia) : mq.addListener(handleMedia);
    };

    const initQuill = () => {
      registerQuillExtensions();
      const toolbarEl = document.getElementById('toolbar');
      if (!toolbarEl) throw new Error('Toolbar container #toolbar not found in DOM at init time');
      const quill = new Quill('#editor', {
        theme: 'snow',
        placeholder: '',
        modules: { toolbar: toolbarEl },
        formats: ['bold', 'italic', 'underline', 'list', 'align', 'pmid', 'size']
      });
      return { quill, toolbarEl };
    };

    const setupToolbarSnap = (toolbarEl, quill) => {
      const getToolbarNode = () => {
        if (toolbarEl.classList.contains('ql-toolbar')) return toolbarEl;
        return toolbarEl.querySelector('.ql-toolbar');
      };
      const snapToolbarToStart = (behavior = 'auto') => {
        const node = getToolbarNode();
        if (!node) return;
        if (node.scrollWidth <= node.clientWidth) return;
        try {
          node.scrollTo({ left: 0, behavior });
        } catch (_) {
          node.scrollLeft = 0;
        }
      };
      const placeCaretIfBlank = () => {
        if (quill.getLength() > 1) return;
        try {
          quill.setSelection(0, 0, 'api');
        } catch (_) {}
      };
      quill.root.addEventListener('focus', placeCaretIfBlank);
      requestAnimationFrame(() => {
        quill.focus();
        placeCaretIfBlank();
        snapToolbarToStart('auto');
      });
      setTimeout(() => {
        if (!quill.hasFocus()) return;
        placeCaretIfBlank();
      }, 150);
      quill.on('text-change', () => {
        if (quill.getLength() > 1) return;
        placeCaretIfBlank();
      });
      window.addEventListener('resize', () => snapToolbarToStart('auto'), { passive: true });
    };

    const initExport = quill => {
      const exportBtn = document.getElementById('export-pdf');
      if (!exportBtn) return;
      const handleExport = () => {
        exportBtn.classList.add('ql-active');
        setTimeout(() => exportBtn.classList.remove('ql-active'), 400);
        const clone = document.createElement('div');
        clone.innerHTML = quill.root.innerHTML;
        clone.querySelectorAll('.ql-pmid').forEach(createAnchorForPMID);
        const printWindow = window.open('', '_blank', 'width=900,height=700');
        if (!printWindow) return;
        const markup = `<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Abstract Atelier Export</title>
  <style>
    body { font-family: "Inter", Arial, sans-serif; margin: 40px; line-height: 1.5; font-size: 11pt; color: #111827; }
    h1, h2, h3 { color: #0f172a; margin-bottom: .6em; }
    a { color: #1d4ed8; text-decoration: underline; }
    p { margin-bottom: .6em; }
    ul, ol { padding-left: 1.25rem; margin-bottom: .75em; }
    li { margin-bottom: .35em; }
  </style>
</head>
<body>${clone.innerHTML}</body>
</html>`;
        printWindow.document.write(markup);
        printWindow.document.close();
        printWindow.focus();
      };
      exportBtn.addEventListener('click', handleExport);
    };

    const initCopy = quill => {
      const copyBtn = document.getElementById('copy-html');
      const copyIcon = document.getElementById('copy-icon');
      if (!copyBtn || !copyIcon) return;
      const renderCopiedState = copied => {
        if (copied) {
          copyBtn.classList.add('ql-active');
          copyIcon.innerHTML = '<path d="M9 16.2 5.5 12.7l1.4-1.4 2.1 2.1 4.2-4.2 1.4 1.4-5.6 5.6z"/>';
          copyIcon.setAttribute('viewBox', '0 0 24 24');
          copyIcon.setAttribute('fill', 'currentColor');
          copyIcon.classList.add('scale-110');
        } else {
          copyBtn.classList.remove('ql-active');
          copyIcon.innerHTML = '<path d="M16 1H4a2 2 0 0 0-2 2v14h2V3h12V1zm3 4H8a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2zm-1 16H8V7h11v14z"/>';
          copyIcon.setAttribute('viewBox', '0 0 24 24');
          copyIcon.setAttribute('fill', 'currentColor');
          copyIcon.classList.remove('scale-110');
        }
      };
      const showCopySuccess = () => {
        renderCopiedState(true);
        setTimeout(() => renderCopiedState(false), 700);
      };
      const buildClipboardItems = (plain, html) => {
        if (typeof ClipboardItem === 'undefined') return null;
        try {
          return [
            new ClipboardItem({ 'text/plain': new Blob([plain], { type: 'text/plain' }) }),
            new ClipboardItem({ 'text/html': new Blob([html], { type: 'text/html' }) })
          ];
        } catch (error) {
          console.warn('Failed to build ClipboardItem payload, falling back to execCommand.', error);
          return null;
        }
      };
      const handleCopy = async () => {
        const clone = document.createElement('div');
        clone.innerHTML = quill.root.innerHTML;
        clone.querySelectorAll('.ql-pmid').forEach(createAnchorForPMID);
        const html = clone.innerHTML;
        const plain = clone.textContent || '';
        const clipboardItems = buildClipboardItems(plain, html);
        if (clipboardItems) {
          try {
            await navigator.clipboard.write(clipboardItems);
            showCopySuccess();
            return;
          } catch (err) {
            console.warn('Navigator clipboard write failed, attempting fallback.', err);
          }
        }
        const temp = document.createElement('div');
        temp.contentEditable = 'true';
        temp.style.position = 'fixed';
        temp.style.left = '-9999px';
        temp.innerHTML = html;
        document.body.appendChild(temp);
        const selection = window.getSelection();
        const range = document.createRange();
        range.selectNodeContents(temp);
        selection.removeAllRanges();
        selection.addRange(range);
        const success = document.execCommand('copy');
        selection.removeAllRanges();
        document.body.removeChild(temp);
        if (success) {
          showCopySuccess();
        } else {
          console.error('Fallback copy failed');
          alert('Unable to copy. Please ensure clipboard permissions are granted.');
        }
      };
      copyBtn.addEventListener('click', handleCopy);
    };

    const initLayout = quill => {
      const topbarEl = document.getElementById('topbar');
      const editorShell = document.getElementById('editor-shell');
      const getScroller = () => quill.scrollingContainer || quill.root?.parentElement || document.querySelector('#editor .ql-editor')?.parentElement || null;
      const smoothScrollBy = (el, dy) => {
        if (!dy) return;
        try {
          el.scrollTo({ top: el.scrollTop + dy, behavior: 'smooth' });
        } catch (_) {
          el.scrollTop += dy;
        }
      };
      const setMinHeights = () => {
        const topH = topbarEl?.offsetHeight || 0;
        document.documentElement.style.setProperty('--topbar-height', `${topH}px`);
        const H = Math.max(0, window.innerHeight - topH);
        if (editorShell) editorShell.style.minHeight = `${H}px`;
        const editorEl = document.querySelector('#editor .ql-editor');
        if (editorEl) editorEl.style.minHeight = `${H}px`;
      };
      const recalcAnchors = () => {
        const scroller = getScroller();
        if (!scroller) return;
        scroller.style.paddingTop = '0px';
        scroller.style.paddingBottom = '0px';
      };
      const ANCHOR_TOP_PX = 16;
      const ensureCaretBelowTop = () => {
        const scroller = getScroller();
        if (!scroller) return;
        const range = quill.getSelection();
        if (!range) return;
        const bounds = quill.getBounds(range.index, range.length);
        if (bounds && typeof bounds.top === 'number' && bounds.top < ANCHOR_TOP_PX) {
          smoothScrollBy(scroller, bounds.top - ANCHOR_TOP_PX);
        }
      };
      const redoLayout = () => {
        setMinHeights();
        recalcAnchors();
      };
      requestAnimationFrame(redoLayout);
      window.addEventListener('resize', redoLayout, { passive: true });
      quill.on('selection-change', () => {
        redoLayout();
        ensureCaretBelowTop();
      });
      return { ensureCaretBelowTop, redoLayout, topbarEl };
    };

    const initStatsAndHighlighting = (quill, ensureCaretBelowTop) => {
      const statusbar = $('#statusbar');
      const wordsStat = $('#s-words');
      const charsStat = $('#s-chars');
      const pmidsStat = $('#s-pmids');
      if (!wordsStat || !charsStat || !pmidsStat) return;
      const updateStats = () => {
        const text = quill.getText();
        const trimmedText = text.trim();
        const words = trimmedText ? trimmedText.split(/\s+/).length : 0;
        const chars = trimmedText.length;
        const pmidCount = extractUniquePMIDs(trimmedText).length;
        const selection = quill.getSelection();
        let selectionWords = 0;
        let selectionChars = 0;
        let selectionPmids = 0;
        const hasSelection = !!(selection && selection.length > 0);
        if (hasSelection) {
          const selectionText = quill.getText(selection.index, selection.length);
          const trimmedSelection = selectionText.trim();
          selectionWords = trimmedSelection ? trimmedSelection.split(/\s+/).length : 0;
          selectionChars = trimmedSelection.length;
          selectionPmids = extractUniquePMIDs(trimmedSelection).length;
        }
        const renderStat = (statEl, selectionValue, totalValue, label) => {
          const statTextEl = statEl.querySelector('.stat-text');
          if (!statTextEl) return;
          statTextEl.innerHTML = '';
          if (hasSelection) {
            statTextEl.append(document.createTextNode(`${selectionValue}/`));
          }
          const totalSpan = document.createElement('span');
          totalSpan.className = 'stat-total';
          totalSpan.textContent = totalValue;
          statTextEl.append(totalSpan);
          const labelValue = hasSelection ? `${selectionValue}/${totalValue}` : totalValue;
          statEl.setAttribute('aria-label', `${label} ${labelValue}`);
        };
        renderStat(wordsStat, selectionWords, words, 'Words');
        renderStat(charsStat, selectionChars, chars, 'Chars');
        renderStat(pmidsStat, selectionPmids, pmidCount, 'PMIDs');
        if (!statusbar) return;
        const statDigits = (hasSelection
          ? [selectionWords, words, selectionChars, chars, selectionPmids, pmidCount]
          : [words, chars, pmidCount])
          .reduce((sum, value) => sum + String(value).length, 0);
        const totalDigits = statDigits + (hasSelection ? 3 : 0);
        const basePad = 16 + Math.min(12, Math.max(0, totalDigits - 3)) * 1.2;
        statusbar.style.setProperty('--pill-pad', `${basePad}px`);
        statusbar.style.setProperty('--pill-pad-expanded', `${basePad + 16}px`);
      };
      const highlightPMIDs = () => {
        const text = quill.getText();
        const len = quill.getLength();
        const selection = quill.getSelection();
        quill.formatText(0, len, 'pmid', false, 'silent');
        let match;
        while ((match = PMID_PATTERN.exec(text)) !== null) {
          const pmid = match[2] || match[3] || match[4] || match[5] || match[6];
          if (!pmid) continue;
          quill.formatText(match.index, match[0].length, 'pmid', pmid, 'silent');
        }
        if (selection) quill.setSelection(selection.index, selection.length, 'silent');
      };
      const refresh = debounce(() => {
        highlightPMIDs();
        updateStats();
        ensureCaretBelowTop();
      }, 60);
      quill.on('text-change', refresh);
      quill.on('selection-change', updateStats);
      updateStats();
      highlightPMIDs();
    };

    const initPmidSidebar = quill => {
      const sidebar = $('#pmid-sidebar');
      const listEl = sidebar ? $('#pmid-card-list', sidebar) : null;
      const countEl = sidebar ? $('#pmid-sidebar-count', sidebar) : null;
      const emptyState = sidebar ? $('#pmid-sidebar-empty', sidebar) : null;
      if (!sidebar || !listEl || !countEl || !emptyState) return;

      let activePmid = null;
      let activeCard = null;
      const cardMap = new Map();
      const mentionCycleIndex = new Map();

      const formatAriaLabel = (card, baseLabel) => {
        if (!card || !baseLabel) return;
        const mentions = Math.max(1, Number(card.dataset.mentions || '1'));
        const mentionText = mentions > 1 ? ` · ${mentions} mentions` : '';
        card.setAttribute('aria-label', `${baseLabel}${mentionText}`);
      };

      const setCardStack = (card, occurrences = 1) => {
        if (!card) return;
        const mentions = Math.max(1, occurrences || 1);
        const visibleLayers = Math.min(4, mentions) - 1;
        card.dataset.mentions = String(mentions);

        const countBadge = card.querySelector('.pmid-card-count');
        if (countBadge) {
          if (mentions > 1) {
            countBadge.textContent = mentions > 99 ? '99+' : String(mentions);
            countBadge.classList.add('is-visible');
          } else {
            countBadge.textContent = '';
            countBadge.classList.remove('is-visible');
          }
        }

        const layersContainer = card.querySelector('.pmid-card-layers');
        if (!layersContainer) {
          if (card.dataset.labelBase) formatAriaLabel(card, card.dataset.labelBase);
          return;
        }
        layersContainer.textContent = '';
        for (let i = 1; i <= visibleLayers; i++) {
          const layer = document.createElement('div');
          layer.className = `pmid-card-layer layer-${i}`;
          layersContainer.appendChild(layer);
        }
        if (card.dataset.labelBase) formatAriaLabel(card, card.dataset.labelBase);
      };

      const toggleInlineHighlight = (pmid, active) => {
        if (!pmid) return;
        document.querySelectorAll(`.ql-pmid[data-pmid="${pmid}"]`).forEach(node => {
          node.classList.toggle('pmid-inline-highlight', active);
        });
      };

      const setActive = (pmid, card) => {
        if (activePmid === pmid && activeCard === card) return;
        if (activePmid) toggleInlineHighlight(activePmid, false);
        if (activeCard) activeCard.classList.remove('is-hovered');
        const previousPmid = activePmid;
        activePmid = pmid || null;
        activeCard = card || null;
        if (activePmid && previousPmid !== activePmid) {
          mentionCycleIndex.set(activePmid, -1);
        }
        if (activePmid && activeCard) {
          toggleInlineHighlight(activePmid, true);
          activeCard.classList.add('is-hovered');
        }
      };

      const clearActive = () => setActive(null, null);

      const scrollInlineIntoView = (pmid, options = {}) => {
        if (!pmid) return;
        const { cycle = false, duration = 640, easing = easeOutCubic } = options;
        const mentions = Array.from(quill.root.querySelectorAll(`.ql-pmid[data-pmid="${pmid}"]`));
        if (!mentions.length) return;

        let index = mentionCycleIndex.get(pmid);
        if (!Number.isInteger(index)) index = -1;
        if (cycle) {
          index = (index + 1) % mentions.length;
        } else if (index < 0 || index >= mentions.length) {
          index = 0;
        }
        mentionCycleIndex.set(pmid, index);

        const target = mentions[index];
        if (!target) return;

        // Choose the correct scroller. Fall back to the document if the editor container is not scrollable.
        let scroller = quill.scrollingContainer || document.documentElement;
        const docEl = document.documentElement;
        const body = document.body;
        let isDocument = (scroller === docEl || scroller === body);

        if (!isDocument) {
          const canScroll = (scroller.scrollHeight - scroller.clientHeight) > 1;
          if (!canScroll) {
            scroller = docEl;
            isDocument = true;
          }
        }

        const scrollerRect = !isDocument && scroller.getBoundingClientRect
          ? scroller.getBoundingClientRect()
          : { top: 0, height: window.innerHeight || docEl.clientHeight || 0 };

        const targetRect = target.getBoundingClientRect();

        const currentScrollTop = isDocument
          ? (window.scrollY ?? window.pageYOffset ?? docEl.scrollTop ?? 0)
          : (scroller.scrollTop || 0);

        const topbar = document.getElementById('topbar');
        const cssTopbar = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height')) || 0;
        const topbarHeight = (topbar?.offsetHeight || cssTopbar || 0);

        const viewportHeight = isDocument
          ? (window.innerHeight || docEl.clientHeight || 0)
          : (scroller.clientHeight || scrollerRect.height || 0);
        if (!viewportHeight) return;

        const targetHeight = targetRect.height || target.offsetHeight || 0;
        const visibleViewportHeight = isDocument ? Math.max(0, viewportHeight - topbarHeight) : viewportHeight;

        const centerOffset = isDocument ? (topbarHeight + (visibleViewportHeight / 2)) : (viewportHeight / 2);
        const targetCenterOffset = (targetRect.top - scrollerRect.top) + (targetHeight / 2);

        let destination = currentScrollTop + targetCenterOffset - centerOffset;
        if (!Number.isFinite(destination)) return;

        const maxScroll = isDocument
          ? Math.max(0, Math.max(docEl.scrollHeight || 0, body?.scrollHeight || 0) - viewportHeight)
          : Math.max(0, (scroller.scrollHeight || 0) - viewportHeight);

        destination = Math.min(Math.max(0, destination), maxScroll);

        animateScrollTo(isDocument ? document.documentElement : scroller, destination, { isDocument, duration, easing });
        quill.focus();
      };

      const bindInteractions = card => {
        card.addEventListener('mouseenter', () => setActive(card.dataset.pmid, card));
        card.addEventListener('mouseleave', clearActive);
        card.addEventListener('focus', () => setActive(card.dataset.pmid, card));
        card.addEventListener('blur', clearActive);
        card.addEventListener('click', event => {
          event.preventDefault();
          const pmid = card.dataset.pmid;
          if (!pmid) return;
          setActive(pmid, card);
          scrollInlineIntoView(pmid, { cycle: true, duration: 640 });
        });
        card.addEventListener('keydown', event => {
          if (event.key !== 'Enter' && event.key !== ' ') return;
          event.preventDefault();
          const pmid = card.dataset.pmid;
          if (!pmid) return;
          setActive(pmid, card);
          scrollInlineIntoView(pmid, { cycle: true, duration: 640 });
        });
      };

      // Allow clicking inline PMID tokens to cycle through mentions with smooth ease-out
      quill.root.addEventListener('click', event => {
        const token = event.target && event.target.closest('.ql-pmid');
        if (!token) return;

        // Do not hijack true text selections
        const sel = window.getSelection && window.getSelection();
        if (sel && sel.rangeCount && !sel.getRangeAt(0).collapsed) return;

        event.preventDefault();
        const pmid = token.getAttribute('data-pmid');
        if (!pmid) return;

        const card = cardMap.get(pmid);
        if (card) setActive(pmid, card);
        scrollInlineIntoView(pmid, { cycle: true, duration: 640 });
      });

      const buildCard = pmid => {
        const card = document.createElement('button');
        card.type = 'button';
        card.className = 'pmid-card';
        card.dataset.pmid = pmid;
        card.dataset.labelBase = `PMID ${pmid} (loading)`;
        card.innerHTML = `
          <div class="pmid-card-layers" aria-hidden="true"></div>
          <span class="pmid-card-count" aria-hidden="true"></span>
          <div class="pmid-card-body">
            <div class="pmid-card-meta">
              <span>PMID ${pmid}</span>
              <span class="pmid-card-year pmid-card-loading">•••</span>
            </div>
            <div class="pmid-card-title pmid-card-loading">Fetching citation…</div>
            <div class="pmid-card-journal pmid-card-loading">Loading journal…</div>
          </div>
        `;
        setCardStack(card, 1);
        bindInteractions(card);
        return card;
      };

      const applyMetadata = (card, metadata) => {
        if (!card || !metadata) return;
        const pmidLabel = metadata.pmid || card.dataset.pmid || '';
        card.dataset.labelBase = `PMID ${pmidLabel} · ${metadata.title || 'Citation'}`;
        formatAriaLabel(card, card.dataset.labelBase);
        const yearEl = card.querySelector('.pmid-card-year');
        if (yearEl) {
          yearEl.textContent = metadata.year || '—';
          yearEl.classList.remove('pmid-card-loading', 'pmid-card-error');
        }
        const titleEl = card.querySelector('.pmid-card-title');
        if (titleEl) {
          titleEl.textContent = metadata.title || 'Title unavailable';
          titleEl.classList.remove('pmid-card-loading', 'pmid-card-error');
        }
        const journalEl = card.querySelector('.pmid-card-journal');
        if (journalEl) {
          journalEl.textContent = metadata.journalAbbrev || metadata.journalTitle || 'Journal unavailable';
          journalEl.classList.remove('pmid-card-loading', 'pmid-card-error');
        }
      };

      const applyError = card => {
        if (!card) return;
        card.dataset.labelBase = `PMID ${card.dataset.pmid || ''} unavailable`;
        formatAriaLabel(card, card.dataset.labelBase);
        const yearEl = card.querySelector('.pmid-card-year');
        if (yearEl) {
          yearEl.textContent = '—';
          yearEl.classList.remove('pmid-card-loading');
        }
        const titleEl = card.querySelector('.pmid-card-title');
        if (titleEl) {
          titleEl.textContent = 'Unable to load citation';
          titleEl.classList.remove('pmid-card-loading');
          titleEl.classList.add('pmid-card-error');
        }
        const journalEl = card.querySelector('.pmid-card-journal');
        if (journalEl) {
          journalEl.textContent = 'Try again later.';
          journalEl.classList.remove('pmid-card-loading');
          journalEl.classList.add('pmid-card-error');
        }
      };

      const updateSidebar = debounce(() => {
        const text = quill.getText();
        const mentionsMap = countPMIDMentions(text);
        const pmids = extractUniquePMIDs(text);
        countEl.textContent = String(pmids.length);
        emptyState.style.display = pmids.length ? 'none' : 'block';
        sidebar.classList.toggle('has-items', pmids.length > 0);

        if (!pmids.length) {
          clearActive();
          cardMap.forEach(card => {
            if (card.parentElement === listEl) listEl.removeChild(card);
          });
          cardMap.clear();
          mentionCycleIndex.clear();
          return;
        }

        const remaining = new Set(cardMap.keys());
        pmids.forEach(pmid => {
          remaining.delete(pmid);
          if (!cardMap.has(pmid)) {
            const card = buildCard(pmid);
            cardMap.set(pmid, card);
            fetchPmidMetadata(pmid)
              .then(metadata => applyMetadata(card, metadata))
              .catch(() => applyError(card));
          }
          const card = cardMap.get(pmid);
          if (card) {
            const mentions = mentionsMap.get(pmid) || 1;
            setCardStack(card, mentions);
            listEl.appendChild(card);
          }
        });

        remaining.forEach(pmid => {
          const card = cardMap.get(pmid);
          if (card && card.parentElement === listEl) listEl.removeChild(card);
          cardMap.delete(pmid);
          mentionCycleIndex.delete(pmid);
        });

        if (activePmid && !cardMap.has(activePmid)) {
          clearActive();
        }
      }, 160);

      updateSidebar();
      quill.on('text-change', updateSidebar);
    };

    const initPersistence = quill => {
      let canPersist = true;
      const save = debounce(() => {
        if (!canPersist) return;
        try {
          const delta = quill.getContents();
          localStorage.setItem(STORAGE_KEYS.content, JSON.stringify(delta));
        } catch (error) {
          canPersist = false;
          console.warn('Unable to persist editor state', error);
        }
      }, 300);
      let stored = null;
      try {
        stored = localStorage.getItem(STORAGE_KEYS.content);
      } catch (error) {
        canPersist = false;
        console.warn('Unable to access stored editor state', error);
      }
      if (stored) {
        try {
          const parsed = JSON.parse(stored);
          if (parsed && typeof parsed === 'object') {
            quill.setContents(parsed);
          }
        } catch (error) {
          console.warn('Stored editor state is invalid; clearing it', error);
          try {
            localStorage.removeItem(STORAGE_KEYS.content);
          } catch (_) {}
        }
      }
      quill.on('text-change', save);
    };

    const initPopup = (quill, topbarEl) => {
      const popup = $('#popup');
      if (!popup) return;
      let hideId = null;
      let anchor = null;
      const placePopup = rect => {
        const vw = innerWidth;
        const vh = innerHeight;
        const pad = 16;
        const topbarBottom = topbarEl ? topbarEl.getBoundingClientRect().bottom : 0;
        const width = Math.min(640, vw * 0.92);
        const height = Math.min(480, popup.offsetHeight || 300);
        let left = rect.left + rect.width / 2 - width / 2;
        left = Math.max(pad, Math.min(left, vw - width - pad));
        let top = rect.bottom + pad;
        const bottomLimit = vh - pad;
        if (top + height > bottomLimit) {
          const aboveTop = rect.top - height - pad;
          top = aboveTop >= topbarBottom + pad ? aboveTop : bottomLimit - height;
        }
        top = Math.max(top, topbarBottom + pad);
        if (top + height > bottomLimit) top = Math.max(topbarBottom + pad, bottomLimit - height);
        popup.style.left = `${left}px`;
        popup.style.top = `${top}px`;
        popup.style.width = `${width}px`;
        popup.style.maxHeight = '70vh';
      };
      const showPopup = async element => {
        const pmid = element.getAttribute('data-pmid');
        if (!pmid) return;
        anchor = element;
        popup.classList.remove('hidden');
        popup.innerHTML = '<div class="flex items-center gap-2 text-gray-600 dark:text-gray-300"><svg class="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg><span>Loading abstract</span></div>';
        placePopup(element.getBoundingClientRect());
        try {
          const metadata = await fetchPmidMetadata(pmid);
          const citationMarkup = metadata.citation
            ? `<div class="text-xs text-gray-500 dark:text-gray-400 mb-2 text-center">${metadata.citation}</div>`
            : '';
          const abstractMarkup = metadata.abstractHtml
            ? `<div class="abstract-box text-sm leading-relaxed nice-scroll max-h-60 overflow-y-auto rounded-lg px-3 py-3">${metadata.abstractHtml}</div>`
            : '';
          const authorsText = metadata.authorsDisplay || 'Authors not found';
          const authorsSpacingClass = metadata.abstractHtml ? 'mb-3' : 'mb-0';
          popup.innerHTML = `
            <div class="text-lg font-bold mb-1 leading-snug text-center">${metadata.title}</div>
            ${citationMarkup}
            <div class="text-sm text-gray-700 dark:text-gray-300 ${authorsSpacingClass} text-center">${authorsText}</div>
            ${abstractMarkup}
            <div class="mt-3 flex items-center justify-center text-gray-700 dark:text-gray-300">
              <a class="ql-pmid inline-flex items-center text-xs leading-none px-3 py-1" href="https://pubmed.ncbi.nlm.nih.gov/${pmid}/" target="_blank" rel="noopener noreferrer">PMID: ${pmid}</a>
            </div>
          `;
          placePopup(element.getBoundingClientRect());
        } catch (error) {
          popup.innerHTML = '<div class="text-red-500">Error loading abstract</div>';
          placePopup(element.getBoundingClientRect());
        }
      };
      const hidePopup = () => {
        popup.classList.add('hidden');
        anchor = null;
      };
      quill.root.addEventListener('mouseover', event => {
        const target = event.target.closest('.ql-pmid');
        if (!target) return;
        clearTimeout(hideId);
        showPopup(target);
      });
      quill.root.addEventListener('mouseout', event => {
        const target = event.target.closest('.ql-pmid');
        if (!target) return;
        hideId = setTimeout(hidePopup, 220);
      });
      popup.addEventListener('mouseenter', () => clearTimeout(hideId));
      popup.addEventListener('mouseleave', () => {
        hideId = setTimeout(hidePopup, 220);
      });
      window.addEventListener('scroll', () => {
        if (!popup.classList.contains('hidden') && anchor) placePopup(anchor.getBoundingClientRect());
      }, { passive: true });
      window.addEventListener('resize', () => {
        if (!popup.classList.contains('hidden') && anchor) placePopup(anchor.getBoundingClientRect());
      });
    };

    // Main Init
    const init = () => {
      initThemeToggle();
      const { quill, toolbarEl } = initQuill();
      const sidebarEl = document.getElementById('pmid-sidebar');
      initSidebarToggle(sidebarEl);
      setupToolbarSnap(toolbarEl, quill);
      initExport(quill);
      initCopy(quill);
      const { ensureCaretBelowTop, topbarEl } = initLayout(quill);
      initStatsAndHighlighting(quill, ensureCaretBelowTop);
      initPmidSidebar(quill);
      initPersistence(quill);
      initPopup(quill, topbarEl);
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init, { once: true });
    } else {
      init();
    }
  })();
</script>
</body>
</html>
